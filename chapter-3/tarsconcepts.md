
# TARS Concepts

In this section, we will introduce some fundamental concepts that you need to understand to develop your project in the TARS framework. We will also provide the rules and conventions used in the framework you should follow to ensure a smooth TARS experience. The topics covered here include service naming rules, template configuration, startup configuration, tars file directory specification, server development mode, client development mode, and development and debugging release.

## TARS Concepts: Service Naming Rules

Before you get started with the development process, it is crucial to understand the three-layer structure of a service’s full name. This structure can avoid any conflict when the server and servant names adopted by different developers overlap. Please keep this in mind when devising your development plan accordingly.

A full name of a service using the TARS framework has three components:

    APP
    Server
    
    Servant
Let’s discuss them in more detail.

APP refers to the application name, which identifies a group of services. Developers can define it according to their needs, usually based on the functionality of the service/project. Please keep in mind the following rules:

- The application name must be unique.
- As a convention, the application name corresponds to a namespace or package name in the code.
- Please note that the application name "tars" is used by the framework and should not be used for business services.

Server refers to the service name, the name of the process that provides services. Please keep in mind the following rules:

- Usually, the server name is named according to the business service function. It will be displayed on the left service tree of the TarsWeb as shown below.


- A server must belong to an APP, and each server name under the APP is unique.
- Follow this format: xxServer. For example, LogServer and TimerServer.
- A server represents an independent program, is bound to at least one IP, and implements a set of related interfaces.

Servant is a service provider, which provides one or more specific interfaces. Please keep in mind the following rules:

- Servant corresponds to a class in the service code, which inherits from the interface in the tars protocol file.
- A servant must belong to a server. The servant names under the server are unique.
- Servant needs an obj name, such as HelloObj. When provided to the client, the full name is shown in the following format, App.Server.Servant (e.g., Test.HelloServer.HelloObj).
- Each servant refers to an independent port of the server.
- When the client calls the server, it only needs to specify the name of the servant to complete remote communication.

## TARS Concepts: Template Configuration

The template configuration (from now on called ‘template’) plays an important role in TARS framework. Every service deployed in the TARS framework is actually published to the application node by the framework. How does the TarsNode know the port, the number of threads, and other information when it starts the server? The answer is the template.

The TarsNode will obtain the template of the service (configured during service deployment), generate the startup configuration of the service according to the template, and start the service based on the startup configuration.

Note that the template files of the various programming languages differ from each other.

We do not recommend modifying the template provided by the framework; however, its content may be modified in a future framework upgrade. If you insist on modifying it, you should inherit the template and let your service use the inherited one.

## TARS Concepts: Startup Configuration

The startup configuration is generated by TarsNode combining template configuration and information about the server. If you want to run the service locally, you must have this configuration file locally in this directory: /usr/local/app/tars/tarsnode/data/TestApp.HelloServer/conf.

A complete startup configuration is as follows:

    <tars> 
    <application>
        enableset=n
        setdivision=NULL
        <server>
        #Ip:port of local node
        node=tars.tarsnode.ServerObj@tcp -h 10.120.129.226 -p 19386 -t 60000
        #Application name
        app=TestApp
        #Server name
        server=HelloServer
        #Local ip
        localip=10.120.129.226
        #Management port
        local=tcp -h 127.0.0.1 -p 20001 -t 3000
        #The server's executable files, configuration files, and so on
    basepath=/usr/local/app/tars/tarsnode/data/TestApp.HelloServer/bin/
        #Data directory of the server
    datapath=/usr/local/app/tars/tarsnode/data/TestApp.HelloServer/data/
        #Log path
        logpath=/usr/local/app/tars/app_log/
        #Rolling log size
        logsize=10M
        #The address of the configuration center
        config=tars.tarsconfig.ConfigObj
        #The address of the report [optional]
        notify=tars.tarsnotify.NotifyObj
        #The address of the remote log [optional]
        log=tars.tarslog.LogObj
        #Timeout time of server stop
        deactivating-timeout=2000
        #Log level
        logLevel=DEBUG
            #Configuration of bound ports
        <TestApp.HelloServer.HelloObjAdapter>
                #Allowed IP address
                allow
                #The IP address of the listener
                endpoint=tcp -h 10.120.129.226 -p 20001 -t 60000
                #Processing group
                handlegroup=TestApp.HelloServer.HelloObjAdapter
                #Maximum connection
                maxconns=200000
                #Protocol
                protocol=tars
                #Queue size
                queuecap=10000
                #The timeout time of the queue (milliseconds)
                queuetimeout=60000
                #Processing object
                servant=TestApp.HelloServer.HelloObj
                #Current thread number
                threads=5
        </TestApp.HelloServer.HelloObjAdapter>
        </server>
        <client>
        #Tarsregistry's address
        locator=tars.tarsregistry.QueryObj@tcp -h 10.120.129.226 -p 17890
        #Synchronous timeout time
        sync-invoke-timeout=3000
        #Asynchronous timeout time
        async-invoke-timeout=5000
        #Refresh the time interval of the IP list
        refresh-endpoint-interval=60000
        #The time interval of the reported data
        report-interval=60000
        #sampling rate
        sample-rate=100000
        #Maximum sampling number
        max-sample-count=50
        #Asynchronous thread number
        asyncthread=3
        #Template name
        modulename=TestApp.HelloServer
        </client>
    </application>
    </tars>

Note:

- node=tars.tarsnode.ServerObj@xxxx, indicates the address of the connected TarsNode. If there is no TarsNode locally, this configuration can be removed.
- local=..., indicates the open port to which the local TarsNode can connect. If there is no local TarsNode, this configuration can be removed.
- locator=..., indicates the address of the TarsRegistry.
- If you are an independent client, with this configuration, you can access the server without specifying its IP and port.

## TARS Concepts: Tars File Directory Specification

The tars file describes the protocol communication interface of TARS. Especially when the client calls the server, it needs to rely on the tars protocol file of the server. We recommend the following management methods:

- In principle, the tars file is placed together with the corresponding server.
- Each server is established on the development machine, in the /home/tarsproto/[namespace]/[server] subdirectory.
- All tars files need to be updated to the directory of the corresponding server under /home/tarsproto.
- We use the tars files of other servers in the directory, /home/tarsproto.
- In this way, when developing on the same development machine, we only need to copy the tars file to /home/tarsproto, which is convenient for other developers to use.
- In principle, the interface of TARS servers can only be added, and cannot be reduced or modified.
- The tools provided by the TARS framework of different programming languages can quickly copy tars files to /home/tarsproto/[namespace]/[server].

## TARS Concepts: Server Development Mode

The development mode of TARS server and client is similar in any programming language.

- Determine the name of App, Server, and Servant.
- Write the tars file, define the interface provided by the server and the functions under the interface. There must be an interface that can connect to one or many functions.
- Use the tars2xxx tool (different programming languages have different tools, e.g., tars2go, tars2cpp...) to generate code in different programming languages from the tars file.
- Write the code of TARS server, inherit the servant class in the generated file, and implement the interface of the servant.
- Compile the code and publish it through TarsWeb (APP, Server, Servant name, etc., need to be configured on the TarsWeb in advance).
Of course, our server can be run on the local machine.

Normally, the servers are ultimately running on each application node through TarsWeb publishing. But if you want to debug on the local machine, you just need to issue one command to start the server. For example, in C++, this would be:

    HelloServer --config=xxxxx.conf

You can first publish the server to an application node, and then log in to the machine of the application node and run:

    ps -efww | grep ${your server name}

You can see the command line of the running server, copy the configuration file to the local machine, open the configuration file, modify the IP port and other related information, then use the same command line to run locally. The same process also applies to other languages.

## TARS Concepts: Client Development Mode

After completing the coding and starting the server, you will develop the client. The client code could be generated by referencing the tars file, as well as the communicator.

Communicator is a class of client management thread and network. It has corresponding classes in each programming language. Usually, the TARS framework will provide an initialized object for you to use. If it is a simple client, you need to create your own communicator.
If your client is another server and deployed on the TARS framework, you can use the communicator provided by the framework. When calling the server, you do not need to specify the IP port. You only need the servant name of the server, and the framework will automatically address and complete the call.
If your client is an independent client program and is not deployed on the TARS framework, you can create your own communicator. There are two ways to call the server.
Directly specify the IP port of the server (you can specify multiple ports. If there is something wrong, the framework will switch to others automatically). Every programming language works in a similar way. Here is an example based on C++:

Communicator *communicator = new Communicator();
HelloPrx helloPrx = \ communicator->stringToProxy<HelloPrx>("Test.HelloServer.HelloObj@tcp -h \ xxx -p yyy:tcp -h www -p zzz");
helloPrx->call();
The communicator can also point to the tarsregistry of the framework, so you don’t need to specify the IP port. The call method is similar for all language versions. Let’s see an example based on C++:

Communicator *communicator = new Communicator();
communicator->setProperty("locator", "tars.tarsregistry.QueryObj@tcp -h \ xxxx -p 17890");
HelloPrx helloPrx = \ communicator->stringToProxy<HelloPrx>("Test.HelloServer.HelloObj");
helloPrx->call();
In this way, although the client can address and recover, it does not report statistics or monitor properties. If you want to report them, the communicator needs to specify related attributes. For example:

communicator->setProperty("stat", "tars.tarsstat.StatObj");
communicator->setProperty("property", "tars.tarspropery.PropertyObj");

Of course, you can use the configuration file to initialize the communicator directly.

## TARS Concepts: Development and Debugging Release

If you were to manually publish the server through the TarsWeb and then debug, the whole process would be inefficient and time-consuming. However, TARS provides a method to publish the server to the TARS framework quickly. This requires a version of Web >= 2.0.0 and tarscpp > 2.1.0.

- Login to TarsWeb, enter the User Center and create a token.
- You can use curl on Linux to upload and publish a server. Take Test/HelloServer as an example:


        curl http://${your-web-host}/api/upload_and_publish?ticket=${token} \ -Fsuse=@HelloServer.tgz -Fapplication=Test -Fmodule_name=HelloServer \ -Fcomment=dev

The C++ version of cmake has embedded the command line in CMakeLists.txt on the server. The user only needs to run the following commands after using cmake_tars_server.sh to create a server:

    cd build
    cmake .. -DTARS_WEB_HOST=${WEB_HOST} -DTARS_TOKEN=${TOKEN}
    make HelloServer-tar
    make HelloServer-upload

Complete the upload and publish the server.

Note:

- You need to replace your WEB_HOST and TOKEN with your information.
- HelloServer.tgz is C++’s release package and Java corresponds to the war package, and for other programming languages, this will be the same for the release packages you uploaded to the TarsWeb.

Now, let’s get more familiarized with the structure of TarsWeb and what each component does.

## TarsWeb Structure

After you log in to TarsWeb, you should see the below interface.

The navigator of TarsWeb has the following functions:

- Services: includes deployed servers, service management, publish management, service configuration, status monitoring, property monitoring, etc.
- Operation: includes service deployment, expansion, template management, etc.
There are three types of user permissions in TarsWeb, including:

- admin
- operator
- developer

The granularity of permissions can be applied to APP or server.

- For example, when the APP is Test and the server is helloserver, you want to designate the operation permission to user test.
- Add user test on the User Center (in the dropdown menu of admin in the top right corner) > Manage User page.
- Add a new privilege on the Manage Privilege page.
- Select operator as Role, test as Uid, and fill the Flag with Test.HelloServer.

If you want the user(test) to own all servers’ permissions of APP(Test), fill the Flag with Test.

Additionally, you can change permissions in TarsWeb. Select your server > click Privilege > enter the user name(s) in the input box of Operation and/or Developer (use semicolons to separate multiple users).